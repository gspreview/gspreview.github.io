<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>graphscope blog</description>
    <link>https://graphscope.io/blog/</link>
    <atom:link href="https://graphscope.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 26 May 2023 07:46:12 +0000</pubDate>
    <lastBuildDate>Fri, 26 May 2023 07:46:12 +0000</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>Categories, Languages, and Systems of Graph Computing</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/2023-05-25-graph-computing.png&quot; alt=&quot;graph-computing&quot; /&gt;
In this post, we will introduce the categories, languages, and systems of graph computing.&lt;/p&gt;

&lt;h3 id=&quot;what-is-graph-computing&quot;&gt;What is Graph Computing&lt;/h3&gt;

&lt;p&gt;In real life, many types of data can be modeled as a graph, which is an abstract structure. This efficient and compact data format can represent rich information such as topology, attributes, and timing. The goal of graph computing is to mine valuable knowledge or patterns from the graph structure, such as frequent patterns and causal relationships. With the advent of the information age, there is an explosive growth in data volume, which has created a demand for efficient processing of large-scale graph data. Graph computing has become a hot topic in both industry and academia, leading to the development of various graph computing systems and optimization research.&lt;/p&gt;

&lt;p&gt;Due to complex business scenarios, there are various types of graph computing. Currently, there are three main categories of graph computing: graph interactive queries, graph analysis, and graph learning.&lt;/p&gt;

&lt;h3 id=&quot;graph-interactive-queries&quot;&gt;Graph Interactive Queries&lt;/h3&gt;

&lt;p&gt;The graph data is typically vast, and graph interactive queries often focus on a relatively limited number of vertices and edges that satisfy specific criteria. These vertices and edges create specific paths or subgraph patterns, as illustrated in the image below. For example, finding the optimal route from one location to another or logistics path information are typical path query scenarios. Subgraph patterns are another form of graph query where a particular pattern is represented with a subgraph, and matching queries are performed on this subgraph within the entire graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/2023-05-25-graph-interactive-queries.png&quot; alt=&quot;graph-interactive-queries&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 1: Subgraph query (left) and path query (right) &lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The essence of a path query is graph traversal, which generally involves the following steps: first, set specific vertices in the graph to be queried; then, each vertex to be queried finds the target vertex set via its connected edges that meet the criteria, checks whether the target vertices meet the query result, and if so, adds the target to the result set; otherwise, sets the target vertex as a new vertex to be queried. This process is repeated until there are no more vertices to be queried. In summary, during the entire graph query process, the graph is traversed step by step according to the user-specified criteria, and the desired results are obtained in the end.&lt;/p&gt;

&lt;p&gt;Another type of graph query is the subgraph query, which is based on the theoretical foundation of subgraph isomorphism. Users provide the subgraph to be queried (vertices, edges, and the criteria they need to satisfy), and then search for all results that meet the criteria on the data graph. Each result is a subgraph in the data graph that is isomorphic to the query graph, and the vertices and edges mapped by the subgraph satisfy the corresponding criteria on the query graph. In summary, the aim is to search for a specific structure that the user cares about in the large graph.&lt;/p&gt;

&lt;p&gt;The two most common languages for graph queries are &lt;a href=&quot;https://tinkerpop.apache.org/docs/current/reference/&quot;&gt;Gremlin&lt;/a&gt; and &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/3183713.3190657&quot;&gt;Cypher&lt;/a&gt;. Gremlin is based on Groovy, but there are many language variations available for developers to write queries using native programming languages such as Java and Python. It incorporates both imperative and declarative semantics, making it easy to express graph traversal logic. As a result, it has been adopted by numerous graph database systems, including JanusGraph, InfiniteGraph, Cosmos DB, DataStax Enterprise (5.0+), and Amazon Neptune. On the other hand, Cypher is a graph query language that employs pattern matching based on description. Due to its similarity to SQL, it has the advantage of simple syntax and high flexibility. This feature has led to its adoption by systems such as neo4j, RedisGraph, and AgensGraph.&lt;/p&gt;

&lt;p&gt;For instance, if we consider a graph with nodes representing people and locations, the query statements for finding people who live with Mike in both Gremlin and Cypher are shown below.&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;mike&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;lives&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;lives&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;neq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cypher highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;MATCH&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;src:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mike&quot;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;:lives&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;:lives&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;dst:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dst.name&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When it comes to processing data, graph querying has distinct computational features. Its characteristics of massive data and poor locality require the system to optimize various aspects such as distributed task partitioning, load balancing, and communication scheduling. The high computational complexity and low latency requirements of users make the system’s concurrency particularly crucial. The presence of super nodes, causing memory inflation, and limited memory in interactive environments pose significant challenges to memory management in the system.&lt;/p&gt;

&lt;h3 id=&quot;graph-analysis&quot;&gt;Graph Analysis&lt;/h3&gt;
&lt;p&gt;Graph querying involves accessing a limited number of vertices or edges that satisfy specific conditions and returning results in real-time. For example, walking two steps from a particular vertex based on specific conditions and returning the paths that meet the criteria. In contrast, graph analysis involves more complex calculations, focusing on analyzing and mining the overall characteristics of the entire graph or the associated information between entities. This includes clustering all vertices in the graph according to certain rules.&lt;/p&gt;

&lt;p&gt;Graph theory is a traditional branch of mathematics that has been studied for hundreds of years, resulting in numerous algorithms related to graph analysis. These range from classical algorithms like shortest path and connected component to practical problems in artificial intelligence such as community discovery, collaborative filtering, and pattern mining. As a result, graph analysis has been applied in an increasing number of scenarios, and large-scale graph analysis has become a research hotspot. According to GraphX, common categories of graph analysis algorithms include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Simple graph analysis algorithms
    &lt;ul&gt;
      &lt;li&gt;PageRank&lt;/li&gt;
      &lt;li&gt;Shortest path&lt;/li&gt;
      &lt;li&gt;Graph coloring&lt;/li&gt;
      &lt;li&gt;Connected component&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Community discovery algorithms
    &lt;ul&gt;
      &lt;li&gt;Triangle counting&lt;/li&gt;
      &lt;li&gt;K-core decomposition&lt;/li&gt;
      &lt;li&gt;K-Truss&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pattern matching algorithms
    &lt;ul&gt;
      &lt;li&gt;Graph simulation&lt;/li&gt;
      &lt;li&gt;(Sub)graph isomorphism&lt;/li&gt;
      &lt;li&gt;Keyword search&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Collaborative filtering algorithms
    &lt;ul&gt;
      &lt;li&gt;Alternating least squares (ALS)&lt;/li&gt;
      &lt;li&gt;Stochastic gradient descent (SGD)&lt;/li&gt;
      &lt;li&gt;Tensor Factorization&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Structural prediction algorithms
    &lt;ul&gt;
      &lt;li&gt;Loopy belief propagation&lt;/li&gt;
      &lt;li&gt;Max-product linear programs&lt;/li&gt;
      &lt;li&gt;Gibbs sampling&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In 2010, Google publicly released the &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/1807167.1807184&quot;&gt;Pregel&lt;/a&gt; system, marking the first distributed system specifically designed for analyzing large-scale graph data. The system was based on a vertex-centric programming model and sparked a series of subsequent academic research and open-source systems. The programming model used a local, vertex-oriented computing approach, encouraging users to “think like a vertex”. This model has natural scalability and parallelism, making it widely used. Systems that follow this model optimize it from various aspects such as programming interfaces, task partitioning, and execution mechanisms, such as the classic programming model GAS of &lt;a href=&quot;https://www.usenix.org/conference/osdi12/technical-sessions/presentation/gonzalez&quot;&gt;PowerGraph&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Another type of system adopts more advanced programming models, such as &lt;a href=&quot;https://dl.acm.org/doi/abs/10.14778/2732232.2732238&quot;&gt;Giraph++&lt;/a&gt;, which first proposed using subgraphs as the basic unit of computation, achieving higher execution efficiency. The PIE model proposed by &lt;a href=&quot;https://dl.acm.org/doi/abs/10.14778/3137765.3137801&quot;&gt;GRAPE&lt;/a&gt; can automatically parallelize single-machine graph algorithms, greatly reducing the programming difficulty for users while achieving high performance.&lt;/p&gt;

&lt;p&gt;Designing graph analysis systems is a challenging process due to the complexity of graph data. Considerations such as how to effectively utilize underlying hardware resources, how to partition and maintain distributed consistency, how to implement more efficient execution modes and task scheduling strategies, how to develop advanced computing and programming models, and how to create better system fault tolerance mechanisms must all be taken into account.&lt;/p&gt;

&lt;h3 id=&quot;graph-learning&quot;&gt;Graph Learning&lt;/h3&gt;

&lt;p&gt;Graph learning, also known as graph-based machine learning, aims to integrate the structural information of graphs into machine learning models. With the widespread application of artificial intelligence technologies, represented by deep learning, and the stronger expressive power of graph structures, graph learning has become a hot topic and has led to breakthrough progress in causality and interpretability. Graph learning has been applied in various fields, such as search and recommendation, advertising, financial risk control, intelligent transportation, medical care, and cities. However, graph learning also faces new technical challenges, such as large-scale data, heterogeneity of vertices and edges, multimodal attribute features, and dynamic changes in structure or attributes over time.&lt;/p&gt;

&lt;p&gt;The traditional approach to graph learning is graph embedding. Graph embedding represents each vertex in the graph as a low-dimensional vector, retaining as much structural and content information of the graph as possible. This representation vector can be used as a feature for subsequent learning tasks such as link prediction and vertex classification. The figure below shows a classic example, where the left side is the original graph structure, and the right side is a mapping scheme obtained by representation learning. The mapping scheme transforms each vertex in graph A into a point in a two-dimensional coordinate system, that is, a two-dimensional vector. In the coordinate space obtained by the mapping, the closely connected vertices in the original graph (i.e., vertices of the same color) remain close to each other.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/2023-05-25-graph-embedding.png&quot; alt=&quot;graph-embedding&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 2: Graph embedding (https://dl.acm.org/doi/abs/10.1145/2623330.2623732) &lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Significant amount of research has been devoted to graph embedding, leading to various solutions for different types of data, such as isomorphic graphs, heterogeneous graphs, attribute graphs, and dynamic graphs. Classic algorithms such as &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/2623330.2623732&quot;&gt;DeepWalk&lt;/a&gt;, &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/2736277.2741093&quot;&gt;LINE&lt;/a&gt;, and &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/2939672.2939754&quot;&gt;Node2Vec&lt;/a&gt; propose different approaches to generate data based on random walks, followed by parameter optimization through training to generate a probabilistic model.&lt;/p&gt;

&lt;p&gt;Another crucial type of graph learning is graph neural networks (GNNs). Traditional neural networks are limited to solving problems in Euclidean space, where data is complete, neat, and regular. For example, in a photo, each pixel is fixedly adjacent to eight vertices, enabling each vertex to correspond to a vector of the same length containing its own information and neighbor information. However, GNN extends classic neural network models like Recurrent Neural Networks (RNNs) and Convolutional Neural Networks (CNNs) to graphs, allowing it to solve problems in non-Euclidean space. This is because the graph structure is irregular, where the number of neighbors of each vertex is different, leading to local dimensions of variable length. Unlike graph embedding, where the focus is on learning the embedding of each vertex, the primary purpose of GNN is to learn the aggregation function, allowing all vertices to calculate their embedding using the same function based on local information. Even if the graph structure changes or a new graph is encountered, meaningful results can still be calculated using the original function. Several classic algorithms for GNN exist, and readers can refer to &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S2666651021000012&quot;&gt;relevant literature&lt;/a&gt; to learn more.&lt;/p&gt;

&lt;p&gt;In summary, both graph embedding and GNNs are essential types of graph learning that play different roles in integrating the structural information of graphs into machine learning models. They have made significant contributions to causality, interpretability, and have been applied in various fields. However, as graph datasets become more complex and diverse, it is crucial to continue developing new techniques and algorithms to address these challenges.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Due to the strong dependency, poor locality, irregular distribution, and diverse structures of graph data, traditional parallel systems for big data are difficult to apply. In addition, different types of computational features and paradigms also bring diversified requirements for the design of graph computing systems.&lt;/p&gt;

&lt;p&gt;An ideal graph computing system should be versatile, high-performance, and easy to use. In terms of versatility, we hope that it supports multiple types of computations such as graph interactive queries, graph analysis, and graph learning, and compatible with language standards and the industry ecology. In terms of performance, it should support low-latency interactive queries, have high-performance graph analysis capabilities, provide large-scale graph storage, and achieve high scalability. In terms of ease of use, it should provide a unified programming model, highly abstracted, simple and flexible language, and implement simple system deployment, easy cluster management, and provide a visual interface.&lt;/p&gt;

&lt;p&gt;To meet the various challenges faced by graph computing systems, meet the needs of real-world application scenarios, and provide one-stop efficient solutions, is the original intention of the GraphScope design. The GraphScope system proposes multiple innovative technologies and is continuously iterating rapidly. It has proved to achieve significant new business value in multiple key internet fields such as risk control, e-commerce recommendation, advertising, network security, knowledge graph, and is committed to empowering more important application scenarios.&lt;/p&gt;
</description>
        <pubDate>Thu, 25 May 2023 03:10:42 +0000</pubDate>
        <link>https://graphscope.io/blog/tech/2023/05/25/Categories-Languages-and-Systems-of-Graph-Computing.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/tech/2023/05/25/Categories-Languages-and-Systems-of-Graph-Computing.html</guid>
        
        
        <category>Tech</category>
        
      </item>
    
      <item>
        <title>Graphs and Graph Applications</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/graph-concept.jpg&quot; alt=&quot;graph-concept&quot; /&gt;
In this post, we will introduce basic concepts of graphs, and some typical applications of graph algorithms.&lt;/p&gt;

&lt;h3 id=&quot;what-is-graph&quot;&gt;What is Graph&lt;/h3&gt;

&lt;p&gt;All things in the universe, from stars and planets as large as they are, to atoms and molecules as small as they are, exist in connections with each other. Graph is the most natural and suitable data structure for describing the relationships between these individual entities. A graph consists of a series of vertices (i.e., individuals) and edges (i.e., relationships between individuals), and both vertices and edges can be accompanied by some description of their own features.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/what-is-graph.jpg&quot; alt=&quot;what-is-graph.jpg&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 1: Graph definition&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The graph data commonly seen in our daily life includes social networks, transportation networks, and biological structure. For example, in social networks, each user can be regarded as a vertex in the graph, and the interactive relationship between users can be regarded as an edge. For instance, WeChat’s social network can be seen as a graph composed of vertices (individuals, official accounts) and edges (follow, like). For a city’s transportation network, we can regard each subway station as a vertex and the lines connecting various subway stations as edges. In the biological structure, each protein can be regarded as a vertex, and the interaction between proteins can be regarded as edges.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/social-networks.png&quot; alt=&quot;social-networks.png&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 2: Social networks (https://medium.com/analytics-vidhya/social-network-analytics-f082f4e21b16)&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/transportation-networks.jpeg&quot; alt=&quot;transportation-networks.jpeg&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 3: Transportation networks（https://studentwork.prattsi.org&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/biological-structure.png&quot; alt=&quot;biological-structure.png&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 4: Biological structure (https://www.biorxiv.org/content/10.1101/2020.08.11.246041v1.full&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;algorithms-and-applications-of-graph-computation&quot;&gt;Algorithms and Applications of Graph Computation&lt;/h3&gt;

&lt;p&gt;Broadly speaking, all analytical calculations based on graph data belong to graph computation, making its application areas very extensive. Considering that graph data can describe the relationships between individual entities, graph computation is particularly suitable for analyzing and computing big data related to correlation relationships. The core of graph computation lies in graph algorithms. In the following, we will classify and introduce some commonly used graph algorithms through a few simple examples.&lt;/p&gt;

&lt;h4 id=&quot;graph-analysis-algorithms&quot;&gt;Graph Analysis Algorithms&lt;/h4&gt;
&lt;p&gt;Graph analysis algorithms analyze and mine the overall characteristics of the whole graph or the local characteristics of partial graph structures by iteratively traversing vertices or edges in graph data. Let’s take path planning as an example to illustrate graph analysis algorithms. Suppose you ordered takeout from a restaurant located at address B while you are at home at address A. How does the delivery man find the optimal delivery route from B to A and deliver the takeout to you as quickly as possible? If we regard every address in the city as a vertex, the road connecting two addresses as an edge, and the length of the road as the feature of the edge, we can transform this problem into finding the shortest path from B to A. To solve this problem, we can use the classic Dijkstra algorithm.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/sssp.jpg&quot; alt=&quot;sssp.jpg&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 5: The shortest path algorithm&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the shortest path algorithm, commonly used graph analysis algorithms also include PageRank (analyzing the importance of vertices in the graph), Breadth-First Search (BFS) (traversing vertices in the graph according to certain rules), and Connected Components (calculating sets of vertices connected to each other in the graph). As shown in the above examples, graph analysis algorithms are based on graph theory and use relationships between vertices to infer the overall or local structural characteristics of complex graph data. We can use these algorithms to discover hidden information and solve practical business problems. For example, search engines can use the PageRank algorithm to rank the weight of web pages and show the most important web pages to users first.&lt;/p&gt;

&lt;h4 id=&quot;community-detection-algorithms&quot;&gt;Community Detection Algorithms&lt;/h4&gt;
&lt;p&gt;“Community” phenomena often exist in graph data, with each community consisting of a group of vertices. For a community, the relationships (edges) between internal vertices are far more than those between external vertices of the community. Community detection algorithms help to discover group behaviors or preferences within communities, find nested relationships, and are often applied to the visualization of graph data.&lt;/p&gt;

&lt;p&gt;Let’s take the analysis of protein function as an example to introduce community detection algorithms. We can regard each protein as a vertex in the graph, and the interaction between proteins as edges, thus forming a protein interaction graph as shown in the figure below. In biology, proteins need to work closely together to complete a specific physiological function. Through community analysis algorithms, we can obtain several communities (proteins in different communities have different colors), and each community of proteins can be considered to cooperate with each other to complete a specific function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/protein-function.png&quot; alt=&quot;protein-function.png&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 6: Community detection algorithm for protein function analysis (https://www.visual-computing.org/2016/01/18/group-structures-graphs/diss_cv01/)&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pattern-matching-algorithms&quot;&gt;Pattern Matching Algorithms&lt;/h4&gt;
&lt;p&gt;Another field in which graph computing can demonstrate its capabilities is pattern matching algorithms. Graph pattern matching aims to find a series of subgraph structures that meet the given pattern, which has been widely used in various business scenarios.
Taking financial transactions as an example, the flow of funds between accounts makes graph data a suitable data structure for representing financial transaction data. In the financial industry, one important type of anomalous transaction that needs to be detected is credit card cash-out, where the funds from a credit card flow through one or more intermediate transactions before returning to the account holder’s account. As shown in the figure below, if we represent the transaction relationship between accounts as a graph structure, this problem can be transformed into finding the “cycle” (starting from a vertex and following the edges can return to this vertex) in the graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/fraud-detection.jpg&quot; alt=&quot;fraud-detection.jpg&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 7: Fraud detection using pattern matching algorithms&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;According to the different structural patterns of the queries, pattern matching algorithms can be divided into the following categories: vertex queries (such as reachability queries, neighbor node queries, etc.), path queries (such as a path satisfying specific conditions), and subgraph structure queries (such as subgraph isomorphism). Pattern matching algorithms are widely used, apart from the financial transaction field, they also play an important role in anomaly event detection in social media and hacker activity detection in computer networks.&lt;/p&gt;

&lt;h4 id=&quot;recommendation-algorithms&quot;&gt;Recommendation Algorithms&lt;/h4&gt;
&lt;p&gt;There is significant commercial value in using social networks to recommend products that users are most interested in. Currently, collaborative filtering algorithms are the most widely used algorithm in recommendation systems, and graph computing can also enhance collaborative filtering algorithms.
For example, if two users are friends and live in the same location, and one user visits a restaurant and likes it, the recommendation algorithm will assume that the other user is also likely to be interested in this restaurant and push the information of the restaurant to her. By constructing a graph structure as shown in the figure below, we can naturally solve these problems on the graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/rec-alog.jpg&quot; alt=&quot;rec-algo.jpg&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 8: Recommendation algorithms based on graphs&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;structure-prediction-algorithms&quot;&gt;Structure Prediction Algorithms&lt;/h4&gt;
&lt;p&gt;Due to the existence of noise in graph data, there are often partial errors in the vertices and edges of the graph, which requires the use of graph structure prediction algorithms to correct the graph data.
As shown in the figure below, in a social network, users A and B have many mutual friends, but there is no edge between A and B. Graph structure prediction algorithms often assume that two people with many mutual friends are likely to be friends, so they believe that there should be an edge between A and B.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/link-prediction.jpg&quot; alt=&quot;link-prediction.jpg&quot; /&gt;&lt;/p&gt;
&lt;center&gt; Figure 9: Link prediction based on graphs&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Traditional graph structure prediction algorithms usually use static indicators such as the number of mutual friends, Katz centrality, and Adamic-Adar to correct the graph structure. In recent years, with the rapid development of deep learning technology, graph neural networks have become another popular class of graph structure prediction algorithms.
Graph neural networks use neural networks to automatically mine features that are closely related to graph structure prediction, which greatly reduces the degree of human involvement and achieves better results compared to traditional methods.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;The core of graph computing is how to model data as a graph structure and how to transform the solution of a problem into a computational problem on the graph structure. When the problem involves relational analysis, graph computing can often naturally represent the solution process as a series of operations and computations on the graph structure. However, the problems that graph computing needs to solve are diverse, and it is difficult to use one set of computation models to solve all problems. We will introduce in detail the classification of graph computing, as well as the characteristics and key technologies of each type of graph computing in later articles.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2023 03:10:42 +0000</pubDate>
        <link>https://graphscope.io/blog/tech/2023/05/22/Graphs-and-Graph-Applications.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/tech/2023/05/22/Graphs-and-Graph-Applications.html</guid>
        
        
        <category>Tech</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.17.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are glad to announce a number of new features and improvements to GraphScope, alongside the GraphScope 0.17 release. The updates include new releases for Spark-GraphX support, backend engine enhancement, and frontend APIs. Currently, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GraphX Pregel&lt;/code&gt; algorithms can be seamlessly executed on GraphScope. A lot of new features have also been officially brought into the interactive engine (GIE), including the syntactic sugar of path expansion and expression, the Gremlin steps of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coin()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;otherV()&lt;/code&gt;,  and the profiling and benchmarking tools for LDBC BI queries.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Spark-GraphX support for GAE:
    &lt;ul&gt;
      &lt;li&gt;Support to convert GraphX graph to GraphScope Fragment;&lt;/li&gt;
      &lt;li&gt;Support to wrap GraphScope Fragment as GraphX Graph;&lt;/li&gt;
      &lt;li&gt;Support to run GraphX Pregel algorithms on GAE.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;New language features and enhancement for GIE:
    &lt;ul&gt;
      &lt;li&gt;The syntactic sugar of path expansion. Now user can write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out[in|both](&apos;x..y&apos;, &apos;KNOWS&apos;)&lt;/code&gt; to support path expansion of at least &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; (included) times and at most &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; (excluded) times from a certain node. Meanwhile, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with()&lt;/code&gt; step can be followed to configure the path expansion.&lt;/li&gt;
      &lt;li&gt;The syntactic sugar of expression, introduced by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expr()&lt;/code&gt;, can be used along with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where()&lt;/code&gt;-step to enable filtering expression. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.where(expr(&quot;@.name == \&quot;John\&quot;&quot;))&lt;/code&gt; helps filter out the current entry that has the name of “John”. We have updated the &lt;a href=&quot;https://graphscope.io/docs/interactive_engine.html&quot;&gt;README doc&lt;/a&gt; for some instructions.&lt;/li&gt;
      &lt;li&gt;Provide LDBC benchmarking for BI queries.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Enhancement and dependency refinement of Groot to reduce the size of fat-jar.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.17.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Sep 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/09/26/release-notes-0.17.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/09/26/release-notes-0.17.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.16.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are bringing a number of improvements to GraphScope, alongside the GraphScope 0.16.0 release. This release introduces many new features on backend engines and system stability. We completely remove a legacy Graph Interactive Engine (GIE), while officially replacing it with the latest version based on an intermediate representation (IR) layer. The Graph Learning Engine (GLE) now supports real-time sampling on dynamic graphs. In addition, the Jave SDK of Graph Analytics Engine (GAE) can work on MacOS. Meanwhile, we start to release a nightly version every day, and you can try it with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pip3 install graphscope --pre&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Enhancements of the GIE GAIA-IR engine:
    &lt;ul&gt;
      &lt;li&gt;Completely replacing the legacy GIE engine with the latest version based on IR layer;&lt;/li&gt;
      &lt;li&gt;Optimizing the logic of lazily fetching properties from the graph store, and implementing a new CSR-based storage for experiment purpose;&lt;/li&gt;
      &lt;li&gt;New language features including more grouping functions, more options for group/dedup/orderby keys, etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic-Graph-Service (DGS) in GLE:
    &lt;ul&gt;
      &lt;li&gt;DGS is an online inference service, and it supports real-time graph sampling for GNN algorithms on dynamic graphs with streaming graph updates;&lt;/li&gt;
      &lt;li&gt;It provides a performance guarantee of sampling P99 latency in 20ms on large-scale dynamic graphs.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Other enhancements:
    &lt;ul&gt;
      &lt;li&gt;Enabling Jave SDK of Graph Analytics Engine (GAE) on MacOS;&lt;/li&gt;
      &lt;li&gt;A series of enhancements on the persistent graph storage &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Groot&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.16.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Aug 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/08/09/release-notes-0.16.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/08/09/release-notes-0.16.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.14.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are delighted to present the release of GraphScope 0.14.0. This release is composed of many updates on backend engines and system stability. The new Graph Interactive Engine (GIE), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GAIA-IR&lt;/code&gt;, has supported more types of operators and graph schemas for diverse graph queries. Meanwhile, the persistent storage of GraphScope, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Groot&lt;/code&gt;, is further enhanced with a series of new functions. In addition, we continuously work on improving the performance of GraphScope, and developer usability.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;New supported operators in GAIA-IR:
    &lt;ul&gt;
      &lt;li&gt;Support the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;valueMap&lt;/code&gt;operator in Gremlin;&lt;/li&gt;
      &lt;li&gt;Enable the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; type as vertex ID type in graph schemas;&lt;/li&gt;
      &lt;li&gt;Support to directly access a vertex via primary key.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;More functions on persistent storage of GraphScope:
    &lt;ul&gt;
      &lt;li&gt;Support to load dataset from Aliyun OSS;&lt;/li&gt;
      &lt;li&gt;Enable local GC for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Groot&lt;/code&gt; storage.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bug fixes and other enhancements:
    &lt;ul&gt;
      &lt;li&gt;Upgrade the NetworkX version from 2.6 to 2.8;&lt;/li&gt;
      &lt;li&gt;A new algorithm named &lt;a href=&quot;[https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.voterank.html?highlight=voterank#networkx.algorithms.centrality.voterank](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.voterank.html?highlight=voterank#networkx.algorithms.centrality.voterank)&quot;&gt;VoteRank&lt;/a&gt; has been supported in the graph analytics engine;&lt;/li&gt;
      &lt;li&gt;Fix some bugs when installing dependencies for GraphScope.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.14.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/06/09/release-notes-0.14.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/06/09/release-notes-0.14.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.13.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are delighted to announce the release of GraphScope v0.13.0. This release is focused on providing a JupyterLab extension for GraphScope to make your graph computation workflows better. In addition, we continuously work on improving performance of GraphScope, and developer usability.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Introducing a JupyterLab extension for GraphScope. Currently, it supports the following functions:
    &lt;ul&gt;
      &lt;li&gt;Providing a graphical user interface for monitoring status of some variables (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;session&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graph&lt;/code&gt;) in your GraphScope program;&lt;/li&gt;
      &lt;li&gt;Supporting to define data schema and load graph data in an interactive way;&lt;/li&gt;
      &lt;li&gt;The extension has been integrated into our &lt;a href=&quot;https://try.graphscope.app/&quot;&gt;GraphScope Playground&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Performance improvement:
    &lt;ul&gt;
      &lt;li&gt;Adding data caching mechanism in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NetworkX&lt;/code&gt; module to improve the performance;&lt;/li&gt;
      &lt;li&gt;Optimizing the performance of converting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arrow_fragment&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic_fragment&lt;/code&gt; with multi-thread.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bug fixes and other enhancements:
    &lt;ul&gt;
      &lt;li&gt;Fixing compilation failure in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdlp&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arrow_flatten_fragment&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;Supporting primary key index in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Groot&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;Adding &lt;a href=&quot;https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.cluster.average_clustering.html&quot;&gt;average clustering&lt;/a&gt; as built-in applications.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.13.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 May 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/05/07/release-notes-0.13.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/05/07/release-notes-0.13.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.12.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
The GraphScope v0.12.0 release is a major update on many aspects of the project including backend engines, APIs, and system stability. It introduces an intermediate representation (IR) layer into the graph interactive engine (GIE) named GAIA, to decouple query languages from query execution engines. Meanwhile, this release supports Giraph APIs to allow Giraph apps directly running on the Graph Analytics Engine (GAE) of GraphScope.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Introduce an IR layer into GAIA:
    &lt;ul&gt;
      &lt;li&gt;A completely redesigned IR layer to decouple the query language dependency, and further for query optimizations.&lt;/li&gt;
      &lt;li&gt;Define the supported Gremlin’s grammar via Antlr.&lt;/li&gt;
      &lt;li&gt;Support &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;match()&lt;/code&gt;-step in Gremlin, for graph pattern matching.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Add Giraph APIs to GAE:
    &lt;ul&gt;
      &lt;li&gt;Support to load graphs with Giraph formats.&lt;/li&gt;
      &lt;li&gt;Support Giraph APIs on GraphScope, and all apps implemented on top of the original Giraph APIs can run on GraphScope without modifications.&lt;/li&gt;
      &lt;li&gt;Users now can add jars with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sess.add_lib()&lt;/code&gt; method.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bug fixes and other enhancements:
    &lt;ul&gt;
      &lt;li&gt;Correct the lifecycle management of loaded graphs within a session.&lt;/li&gt;
      &lt;li&gt;Make the logs of Graph Learning Engine (GLE) more user-friendly.&lt;/li&gt;
      &lt;li&gt;Fix readwrite failed on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graphscope.nx&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Support to connect to an existing ETCD cluster in GraphScope.&lt;/li&gt;
      &lt;li&gt;Support to launch GraphScope on K8s from an inner-pod environment.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.12.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Apr 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/04/02/release-notes-0.12.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/04/02/release-notes-0.12.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.11.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are glad to announce a number of new features and improvements to GraphScope, alongside the GraphScope v0.11.0 release. This major release introduces mutable graphs into GraphScope, and adds GPU supports for graph analytics engine (GAE). It also focuses on user-friendly improvements, code quality, and a series of bug fixes.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Supporting mutable graphs:
    &lt;ul&gt;
      &lt;li&gt;Providing a set of interfaces (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_vertex&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_edge&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update_vertex&lt;/code&gt;) to modify the topology of an existing graph;&lt;/li&gt;
      &lt;li&gt;Adopting existing apps to mutable graphs.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Accelerating graph analytics apps with GPUs:
    &lt;ul&gt;
      &lt;li&gt;Adding new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fragment&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;worker&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message_manager&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apps&lt;/code&gt; to utilize GPUs to process graph analytics tasks faster;&lt;/li&gt;
      &lt;li&gt;On top of these new infrastructures, 6 example algorithms (BFS, WCC, SSSP, PageRank, CDLP and LCC) are implemented;&lt;/li&gt;
      &lt;li&gt;Our GPU-based graph algorithms are about 2x faster compared with state-of-the-art  GPU-based graph processing systems. See detals in &lt;a href=&quot;https://github.com/alibaba/libgrape-lite/blob/master/Performance.md#performance-on-gpus&quot;&gt;performance report&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Optimizations and enhancements:
    &lt;ul&gt;
      &lt;li&gt;Stream grpc request (response) to support loading graph (fetching result) from (to) numpy/pandas more than 2GB;&lt;/li&gt;
      &lt;li&gt;Accelerating manipulation of graph topology by replacing folly::dynamicwith &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rapidjson::value&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.11.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Mar 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/03/06/release-notes-0.11.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/03/06/release-notes-0.11.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.10.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are glad to announce the availability of GraphScope v0.10. This release supports users to run GraphScope on MacOS powered by Apple’s new M1 chip. In addition, it allows to serialize/deserialize graph data to/from the disk under the standalone mode.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Add Apple’s M1 chip support.&lt;/li&gt;
  &lt;li&gt;Improve the implementation and documentation of context selectors.&lt;/li&gt;
  &lt;li&gt;Support serialization/deserialization of graph data on the standalone mode.&lt;/li&gt;
  &lt;li&gt;Refactor &lt;a href=&quot;https://github.com/alibaba/GraphScope/tree/main/analytical_engine/java&quot;&gt;Java SDK&lt;/a&gt; in Graph Analytics Engine.&lt;/li&gt;
  &lt;li&gt;Fix a bug when loading graph data from HDFS.&lt;/li&gt;
  &lt;li&gt;Fix got empty result in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all_simple_path&lt;/code&gt;algorithm with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num_workers=1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.10.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jan 2022 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2022/01/05/release-notes-0.10.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2022/01/05/release-notes-0.10.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
      <item>
        <title>Release Notes: v0.9.0</title>
        <description>&lt;p&gt;&lt;img src=&quot;/blog/assets/images/release_note_t.png&quot; alt=&quot;release-note&quot; /&gt;
We are glad to announce the availability of GraphScope v0.9. In this release, we revisit the Dev-infra to improve productivity. Now, you can enjoy GraphScope with standalone mode in both our &lt;a href=&quot;https://try.graphscope.app/&quot;&gt;PlayGround&lt;/a&gt; and &lt;a href=&quot;https://colab.research.google.com/github/alibaba/GraphScope&quot;&gt;Google Colab&lt;/a&gt;. We also continuously make GraphScope more user-friendly and update the &lt;a href=&quot;https://graphscope.io/docs/installation.html&quot;&gt;documents&lt;/a&gt; and &lt;a href=&quot;https://github.com/alibaba/GraphScope/tree/main/tutorials&quot;&gt;tutorials&lt;/a&gt; based on the latest version. Further, we have preliminary supported Java in Graph Analytics Engine (GAE), and users can succinctly develop graph analytics applications with Java (see &lt;a href=&quot;https://graphscope.io/docs/analytics_engine.html#writing-your-own-algorithms-in-java.&quot;&gt;this document&lt;/a&gt; for more details).&lt;/p&gt;

&lt;p&gt;On the performance side, we have done a lot of work to improve the performance of the distributed GAIA engine, which is used to execute graph interactive queries in GraphScope. The improvements include but are not limited to 1) simplifying the communication protocol that reduces many useless tags in correlated subtask; 2) making early-stop mechanism more effective due to 1); 3) resolving a lot of bugs due to 1); 4) refining the engine apis. As a distributed cyclic data-parallel engine, GAIA engine is in de-facto generic to handle any data-intensive task. Now users can assess to more &lt;a href=&quot;https://github.com/alibaba/GraphScope/tree/main/research/engine/pegasus/pegasus/src/api&quot;&gt;GAIA APIs&lt;/a&gt; (will be well documented) to play with the engine.&lt;/p&gt;

&lt;p&gt;We highlight the following improvements included in this release:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;New features:
    &lt;ul&gt;
      &lt;li&gt;Support GLE (Graph Learning Engine) on MacOS;&lt;/li&gt;
      &lt;li&gt;GIE (Graph Interactive Engine) Runtime refactoring based on the new GAIA engine;&lt;/li&gt;
      &lt;li&gt;Reimplement persistent storage engine with zero-copy read;&lt;/li&gt;
      &lt;li&gt;Add several popular &lt;a href=&quot;https://github.com/alibaba/GraphScope/tree/main/python/graphscope/dataset&quot;&gt;datasets&lt;/a&gt; and ship datasets by adding an extra container in Kubernetes mode;&lt;/li&gt;
      &lt;li&gt;Support NetworkX generator, read, write, drawing, convert with more generators and test cases;&lt;/li&gt;
      &lt;li&gt;Add common labels following Kubernetes best practice to GraphScope cluster;&lt;/li&gt;
      &lt;li&gt;Add transformation ability for directed/undirected graphs;&lt;/li&gt;
      &lt;li&gt;Java SDK in GAE, and examples to write and run algorithms written in Java.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bug Fixes:
    &lt;ul&gt;
      &lt;li&gt;Fix a crash if duplicate property names were encountered when extracting subgraphs;&lt;/li&gt;
      &lt;li&gt;Fix the MPI library not found problem on macOS;&lt;/li&gt;
      &lt;li&gt;Fix context processing on graphs generated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_column&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;Fix many bugs related to subtasks while querying Gremlin;&lt;/li&gt;
      &lt;li&gt;Fix a failure when exposing Gremlin service deployed with Helm Charts.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more detailed improvements that have been made in this release, please refer to the complete &lt;a href=&quot;https://github.com/alibaba/GraphScope/releases/tag/v0.9.0&quot;&gt;changelog&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Dec 2021 03:33:20 +0000</pubDate>
        <link>https://graphscope.io/blog/releasenotes/2021/12/08/release-notes-0.9.0.html</link>
        <guid isPermaLink="true">https://graphscope.io/blog/releasenotes/2021/12/08/release-notes-0.9.0.html</guid>
        
        
        <category>ReleaseNotes</category>
        
      </item>
    
  </channel>
</rss>
